#pragma kernel Simulate
#pragma kernel Emit
#include "SNoise.hlsl"
#define WIDTH 64
#define EPSILON 1e-3


static const float4 Dx = float4(EPSILON, 0, 0, 0);
static const float4 Dy = float4(0, EPSILON, 0, 0);
static const float4 DeathPos = float4(1000, 0, 0, 0);

struct Particle {
	float2 x;
	float t;
	float life;
};

float Dt;
float Time;
float Speed;
float NoiseScale;
StructuredBuffer<float4> Spheres;
StructuredBuffer<Particle> ParticleIn;
RWStructuredBuffer<Particle> ParticleOut;

StructuredBuffer<int> EmitIndices;
StructuredBuffer<Particle> EmitParticles;



float Ramp(float r) {
	if (r >= 1.0)
		return 1.0;
	else if (r <= -1.0)
		return -1.0;
	
	float r3 = r * r * r;
	float r5 = r3 * r * r;
	return (15.0 * r - 10.0 * r3 + 3.0 * r5) * 0.125;
}
float Dist2Sphere(float2 x, float4 sphere) {
	float2 v = x - sphere.xy;
	return length(v) - sphere.w;
}
float2 ClosestOnSphere(float2 x, float4 sphere, out float dist, out float2 n) {
	float2 v = x - sphere.xy;
	dist = length(v) - sphere.w;
	n = normalize(v);
	return sphere.w * n + sphere.xy;
}
float Pot(float3 xt) {
	float3 xt_s = xt * float3(NoiseScale, NoiseScale, 1.0);
	
	uint nSpheres = 0;
	uint stride = 0;
	Spheres.GetDimensions(nSpheres, stride);
	
	float r = 1.0;
	for (uint i = 0; i < nSpheres; i++) {
		float4 sph = Spheres[i];
		float dist = Dist2Sphere(xt.xy, sph);
		r *= Ramp(dist * NoiseScale);
	}
	return r * snoise(xt_s);
}
float2 Curl(float2 x) {
	float3 xt = float3(x, Time);
	float dpdx = Pot(xt + Dx.xyw) - Pot(xt - Dx.xyw);
	float dpdy = Pot(xt + Dy.xyw) - Pot(xt - Dy.xyw);

	return float2(dpdy, -dpdx) / (2.0 * EPSILON * NoiseScale);
}
float2 Constraint(float2 x) {
	uint nSpheres = 0;
	uint stride = 0;
	Spheres.GetDimensions(nSpheres, stride);
	
	for (uint i = 0; i < nSpheres; i++) {
		float4 sph = Spheres[i];
		float dist = 0.0;
		float2 n = 0.0;
		float2 closest = ClosestOnSphere(x, sph, dist, n);
		if (dist < 0.0)
			x = closest;
	}
	
	return x;
}



[numthreads(WIDTH,1,1)]
void Simulate(uint3 id : SV_DispatchThreadID) {
	Particle p = ParticleIn[id.x];
	if (p.t < p.life) {
		p.t += Dt;
		p.x += Speed * Curl(p.x) * Dt;
		p.x = Constraint(p.x);
	} else {
		p.x = DeathPos.xy;
	}
    ParticleOut[id.x] = p;
}
[numthreads(WIDTH,1,1)]
void Emit(uint3 id : SV_DispatchThreadID) {
	int i = EmitIndices[id.x];
	if (i >= 0)
		ParticleOut[i] = EmitParticles[id.x];
}
